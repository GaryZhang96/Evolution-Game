<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Light Survival</title>
    <style>body { margin: 0; overflow: hidden; background: #000; touch-action: none; }</style>
</head>
<body>
    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>
    <script src="/socket.io/socket.io.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        const socket = io();
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
        camera.position.set(0, 100, 100); camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));

        const sun = new THREE.Mesh(new THREE.SphereGeometry(20, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
        scene.add(sun); scene.add(new THREE.PointLight(0xffaa00, 2, 800));

        const meshes = {}; const algaeMeshes = {};
        
        socket.on('state', ({ players, algaes }) => {
            Object.keys(algaeMeshes).forEach(k => { scene.remove(algaeMeshes[k]); delete algaeMeshes[k]; });
            algaes.forEach(a => {
                const m = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                m.position.set(a.x, 0, a.y); scene.add(m); algaeMeshes[a.id] = m;
            });
            Object.keys(meshes).forEach(id => { if(!players[id]) { scene.remove(meshes[id]); delete meshes[id]; } });
            for(let id in players) {
                let p = players[id], m = meshes[id];
                if(!m) { m = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({ color: p.color })); scene.add(m); meshes[id] = m; }
                m.position.lerp(new THREE.Vector3(p.x, 0, p.y), 0.3);
                m.scale.setScalar(p.size);
                if(id === socket.id) {
                    camera.position.lerp(new THREE.Vector3(p.x, 80 + p.size*10, p.y + 60), 0.1);
                    camera.lookAt(p.x, 0, p.y);
                }
            }
        });
        socket.on('dead', () => alert("你挂了！点击确定复活"));

        function sendInput(target) {
            if(meshes[socket.id]) {
                const dir = new THREE.Vector3().subVectors(target, meshes[socket.id].position).normalize();
                socket.emit('input', { x: dir.x, y: dir.z });
            }
        }

        window.addEventListener('mousemove', e => {
            if('ontouchstart' in window) return;
            const vec = new THREE.Vector3((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1, 0.5).unproject(camera).sub(camera.position).normalize();
            sendInput(camera.position.clone().add(vec.multiplyScalar(-camera.position.y/vec.y)));
        });
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            const touch = e.touches[0];
            const vec = new THREE.Vector3((touch.clientX/window.innerWidth)*2-1, -(touch.clientY/window.innerHeight)*2+1, 0.5).unproject(camera).sub(camera.position).normalize();
            sendInput(camera.position.clone().add(vec.multiplyScalar(-camera.position.y/vec.y)));
        }, { passive: false });

        function animate() { requestAnimationFrame(animate); composer.render(); }
        animate();
        window.onresize = () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); };
    </script>
</body>
</html>
